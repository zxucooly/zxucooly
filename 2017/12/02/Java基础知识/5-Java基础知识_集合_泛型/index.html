<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-z-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-z-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://zxucooly.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: true,
    sidebar: {"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"default"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="集合什么是集合？集合是储存对象的容器，面向对象对事物的体现就是对象，所以为了方便对多个对象的操作，存储对象是常用的一种方式。 集合的出现就是为了持有对象。集合中可以存储任意类型的对象, 而且长度可变。在程序中有可能无法预先知道需要多少个对象, 那么用数组来装对象的话, 长度不好定义, 而集合解决了这样的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础知识-集合">
<meta property="og:url" content="https://zxucooly.github.io/2017/12/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E9%9B%86%E5%90%88_%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="ZXUBLOG">
<meta property="og:description" content="集合什么是集合？集合是储存对象的容器，面向对象对事物的体现就是对象，所以为了方便对多个对象的操作，存储对象是常用的一种方式。 集合的出现就是为了持有对象。集合中可以存储任意类型的对象, 而且长度可变。在程序中有可能无法预先知道需要多少个对象, 那么用数组来装对象的话, 长度不好定义, 而集合解决了这样的问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxucooly.github.io/images/collections.png">
<meta property="article:published_time" content="2017-12-01T16:00:00.000Z">
<meta property="article:modified_time" content="2018-11-29T00:50:24.346Z">
<meta property="article:author" content="zxucooly">
<meta property="article:tag" content="java基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxucooly.github.io/images/collections.png">

<link rel="canonical" href="https://zxucooly.github.io/2017/12/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E9%9B%86%E5%90%88_%E6%B3%9B%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>java基础知识-集合 | ZXUBLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZXUBLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">PERSISTENCE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">48</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxucooly.github.io/2017/12/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E9%9B%86%E5%90%88_%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="zxucooly">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZXUBLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础知识-集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-02T00:00:00+08:00">2017-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-29 08:50:24" itemprop="dateModified" datetime="2018-11-29T08:50:24+08:00">2018-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="什么是集合？"><a href="#什么是集合？" class="headerlink" title="什么是集合？"></a>什么是集合？</h2><p>集合是储存对象的容器，面向对象对事物的体现就是对象，所以为了方便对多个对象的操作，存储对象是常用的一种方式。</p>
<p>集合的出现就是为了持有对象。集合中可以存储任意类型的对象, 而且长度可变。在程序中有可能无法预先知道需要多少个对象, 那么用数组来装对象的话, 长度不好定义, 而集合解决了这样的问题。</p>
<a id="more"></a>

<h2 id="集合和数组的区别？"><a href="#集合和数组的区别？" class="headerlink" title="集合和数组的区别？"></a>集合和数组的区别？</h2><ol>
<li>数组和集合类都是容器</li>
<li>数组长度是固定的，集合长度是可变的。数组中可以存储基本数据类型，集合只能存储对象数组中存储数据类型是单一的，集合中可以存储任意类型的对象。</li>
</ol>
<p>集合类的特点：</p>
<p>​    用于存储对象，长度是可变的，可以存储不同类型的对象。</p>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><img src="/images/collections.png" alt="collectios"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---|Collection: 单列集合</span><br><span class="line">			---|List: 有存储顺序, 可重复</span><br><span class="line">				---|ArrayList:	数组实现, 查找快, 增删慢</span><br><span class="line">					     由于是数组实现, 在增和删的时候会牵扯到数组增容, 以及拷贝元素. 所以慢。数组是可以直接按索引查找, 所以查找时较快</span><br><span class="line"></span><br><span class="line">				---|LinkedList:	链表实现, 增删快, 查找慢</span><br><span class="line">						由于链表实现, 增加时只要让前一个元素记住自己就可以, 删除时让前一个元素记住后一个元素, 后一个元素记住前一个元素. 这样的增删效率较高但查询时需要一个一个的遍历, 所以效率较低</span><br><span class="line">						</span><br><span class="line">				---|Vector:	和ArrayList原理相同, 但线程安全, 效率略低</span><br><span class="line">					     和ArrayList实现方式相同, 但考虑了线程安全问题, 所以效率略低</span><br><span class="line">					     </span><br><span class="line">			---|Set: 无存储顺序, 不可重复</span><br><span class="line">				---|HashSet</span><br><span class="line">				---|TreeSet</span><br><span class="line">				---|LinkedHashSet</span><br><span class="line">				</span><br><span class="line">---| Map: 键值对</span><br><span class="line">		---|HashMap</span><br><span class="line">		---|TreeMap</span><br><span class="line">		---|HashTable</span><br><span class="line">		---|LinkedHashMap</span><br></pre></td></tr></table></figure>

<p>为什么出现这么多集合容器，因为每一个容器对数据的存储方式不同，这种存储方式称之为数据结构（data structure）</p>
<p><strong>注意集合和数组中存放的都是对象的引用。</strong></p>
<table>
<thead>
<tr>
<th align="left">Collection</th>
<th align="left">我们需要保存若干个对象的时候使用集合。</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left">如果我们需要保留存储顺序, 并且保留重复元素, 使用List.  如果查询较多, 那么使用ArrayList  如果存取较多, 那么使用LinkedList  如果需要线程安全, 那么使用Vector</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">如果我们不需要保留存储顺序, 并且需要去掉重复元素, 使用Set.  如果我们需要将元素排序, 那么使用TreeSet  如果我们不需要排序, 使用HashSet, HashSet比TreeSet效率高.  如果我们需要保留存储顺序, 又要过滤重复元素, 那么使用LinkedHashSet</td>
</tr>
</tbody></table>
<h1 id="集合类（Collection）"><a href="#集合类（Collection）" class="headerlink" title="集合类（Collection）"></a>集合类（Collection）</h1><p>Collection接口有两个子接口：</p>
<p>List(链表|线性表)</p>
<p>Set(集)</p>
<p>特点：</p>
<p>Collection中描述的是集合共有的功能(CRUD)</p>
<p>List可存放重复元素，元素存取是有序的</p>
<p>Set不可以存放重复元素，元素存取是无序的</p>
<h2 id="Collection的共性方法"><a href="#Collection的共性方法" class="headerlink" title="Collection的共性方法"></a>Collection的共性方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">增加：</span><br><span class="line">		<span class="number">1</span>：<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">()</span>	将指定对象存储到容器中</span></span><br><span class="line"><span class="function">                      add 方法的参数类型是Object 便于接收任意对象</span></span><br><span class="line"><span class="function">		2：<span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">()</span> 将指定集合中的元素添加到调用该方法和集合中</span></span><br><span class="line"><span class="function">		<span class="comment">//c.addAll(c2); // 把c2的元素的添加到c集合中去。</span></span></span><br><span class="line"><span class="function">删除：</span></span><br><span class="line"><span class="function">		3：<span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> 将指定的对象从集合中删除</span></span><br><span class="line"><span class="function">		4：<span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">()</span> 将指定集合中的元素删除</span></span><br><span class="line"><span class="function">		                            </span></span><br><span class="line"><span class="function"><span class="comment">//c.removeAll(c2); //删除c集合中与c2的交集元素。</span></span></span><br><span class="line"><span class="function"><span class="comment">//c.retainAll(c2); //保留c集合与c2的交集元素，其他的元素一并删除。</span></span></span><br><span class="line"><span class="function">修改</span></span><br><span class="line"><span class="function">		5：<span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> 清空集合中的所有元素</span></span><br><span class="line"><span class="function">判断</span></span><br><span class="line"><span class="function">		6：<span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 判断集合是否为空</span></span><br><span class="line"><span class="function">		7：<span class="keyword">boolean</span> <span class="title">contains</span><span class="params">()</span> 判断集合何中是否包含指定对象     </span></span><br><span class="line"><span class="function">		8：<span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">()</span> 判断集合中是否包含指定集合</span></span><br><span class="line"><span class="function">                            使用<span class="title">equals</span><span class="params">()</span>判断两个对象是否相等</span></span><br><span class="line"><span class="function">         例：</span></span><br><span class="line"><span class="function">    @Override</span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		Person p = (Person)obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id == p.id ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//java规范： 一般重写equlas方法我们都会重写hashCode方法的。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">获取:   <span class="number">9</span>：<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>    返回集合容器的大小</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">转成数组10： <span class="title">toArray</span><span class="params">()</span>   集合转换数组</span></span><br><span class="line"><span class="function">     String[] y </span>= x.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]); </span><br><span class="line">注意，toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]) 和 toArray() 在功能上是相同的。</span><br></pre></td></tr></table></figure>

<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><h2 id="List集合特有的方法"><a href="#List集合特有的方法" class="headerlink" title="List集合特有的方法"></a>List集合特有的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List接口中特有方法：</span><br><span class="line">	</span><br><span class="line">	添加</span><br><span class="line">		add(<span class="keyword">int</span> index, E element) </span><br><span class="line">		addAll(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c) </span><br><span class="line">	获取：</span><br><span class="line">		get(<span class="keyword">int</span> index) </span><br><span class="line">		indexOf(Object o) </span><br><span class="line">		lastIndexOf(Object o) </span><br><span class="line">		subList(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) </span><br><span class="line">	修改：</span><br><span class="line">		set(<span class="keyword">int</span> index, E element) </span><br><span class="line"></span><br><span class="line">	迭代</span><br><span class="line">		listIterator()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">		List list=  <span class="keyword">new</span> ArrayList();</span><br><span class="line">		list.add(<span class="string">"狗娃"</span>);</span><br><span class="line">		list.add(<span class="string">"狗剩"</span>);</span><br><span class="line">		list.add(<span class="string">"铁蛋"</span>);  <span class="comment">//把元素添加到集合的末尾处。</span></span><br><span class="line">		list.add(<span class="string">"狗娃"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	       //添加方法</span></span><br><span class="line"><span class="comment">		list.add(1, "赵本山"); // 把元素添加到集合中的指定索引值位置上。</span></span><br><span class="line"><span class="comment">		List list2 = new ArrayList();</span></span><br><span class="line"><span class="comment">		list2.add("本山");</span></span><br><span class="line"><span class="comment">		list2.add("小沈阳");</span></span><br><span class="line"><span class="comment">		list.addAll(2,list2); //把list2的元素添加到list集合指定索引值的位置上。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">//		获取的方法 </span></span><br><span class="line"><span class="comment">		System.out.println("get方法获取元素："+list.get(1)); //根据索引值获取集合中的元素</span></span><br><span class="line"><span class="comment">		使用get方法遍历集合的元素：</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; list.size() ; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.print(list.get(i)+",");</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		System.out.println("找出指定元素第一次出现在集合中 的索引值："+ list.indexOf("本山"));</span></span><br><span class="line"><span class="comment">		System.out.println("找指定的元素最后一次出现在集合中的索引值："+list.lastIndexOf("狗娃"));</span></span><br><span class="line"><span class="comment">		List subList = list.subList(1, 3); //指定开始与结束的索引值截取集合中的元素。</span></span><br><span class="line"><span class="comment">		System.out.println("子集合的元素是："+ subList);</span></span><br><span class="line"><span class="comment">	 */</span>	</span><br><span class="line">		list.set(<span class="number">3</span>, <span class="string">"赵本山"</span>); <span class="comment">//使用指定的元素替换指定索引值位置的元素。</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"集合的元素："</span>+list);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--| Iterable</span><br><span class="line">			  ----| Collection</span><br><span class="line">				 ------| List</span><br><span class="line">				      ---------| ArrayList  底层采用数组实现，默认<span class="number">10</span>。</span><br><span class="line">				      每次增长<span class="number">60</span>%,（(oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>） 查询快，增删慢。</span><br><span class="line">				 ---------| LinkedList          </span><br><span class="line">ArrayList:实现原理：</span><br><span class="line">数组实现, 查找快, 增删慢</span><br><span class="line">数组为什么是查询快?因为数组的内存空间地址是连续的.</span><br><span class="line">	ArrayList底层维护了一个Object[] 用于存储对象，默认数组的长度是<span class="number">10</span>。可以通过 <span class="keyword">new</span> ArrayList(<span class="number">20</span>)显式的指定用于存储对象的数组的长度。</span><br><span class="line">	当默认的或者指定的容量不够存储对象的时候，容量自动增长为原来的容量的<span class="number">1.5</span>倍。</span><br><span class="line">由于ArrayList是数组实现, 在增和删的时候会牵扯到数组增容, 以及拷贝元素. 所以慢。数组是可以直接按索引查找, 所以查找时较快</span><br><span class="line">可以考虑,假设向数组的<span class="number">0</span>角标未知添加元素,那么原来的角标位置的元素需要整体往后移,并且数组可能还要增容,一旦增容,就需要要将老数组的内容拷贝到新数组中.所以数组的增删的效率是很低的.</span><br></pre></td></tr></table></figure>

<h2 id="LinkList集合"><a href="#LinkList集合" class="headerlink" title="LinkList集合"></a>LinkList集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LinkedList:链表实现, 增删快, 查找慢</span><br><span class="line">由于LinkedList:在内存中的地址不连续,需要让上一个元素记住下一个元素.所以每个元素中保存的有下一个元素的位置.虽然也有角标,但是查找的时候,需要从头往下找,显然是没有数组查找快的.但是,链表在插入新元素的时候,只需要让前一个元素记住新元素,让新元素记住下一个元素就可以了.所以插入很快.</span><br><span class="line">由于链表实现, 增加时只要让前一个元素记住自己就可以, 删除时让前一个元素记住后一个元素, 后一个元素记住前一个元素. 这样的增删效率较高。</span><br><span class="line">但查询时需要一个一个的遍历, 所以效率较低。</span><br><span class="line"></span><br><span class="line">特有方法</span><br><span class="line"><span class="number">1</span>：方法介绍</span><br><span class="line">addFirst(E e) </span><br><span class="line">addLast(E e) </span><br><span class="line">getFirst() </span><br><span class="line">getLast() </span><br><span class="line">removeFirst() </span><br><span class="line">removeLast() </span><br><span class="line">如果集合中没有元素，获取或者删除元</span><br><span class="line">素抛：NoSuchElementException</span><br><span class="line"><span class="number">2</span>：数据结构</span><br><span class="line">				<span class="number">1</span>：栈 （<span class="number">1.6</span>）</span><br><span class="line">					先进后出</span><br><span class="line">					push() </span><br><span class="line">					pop()</span><br><span class="line">				<span class="number">2</span>：队列（双端队列<span class="number">1.5</span>）</span><br><span class="line">					先进先出</span><br><span class="line">					offer()</span><br><span class="line">					poll()</span><br><span class="line"><span class="number">3</span>：返回逆序的迭代器对象      </span><br><span class="line">descendingIterator()   返回逆序的迭代器对象</span><br></pre></td></tr></table></figure>

<p>基本方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="string">"西游记"</span>);</span><br><span class="line">list.add(<span class="string">"三国演义"</span>);</span><br><span class="line">list.add(<span class="string">"石头记"</span>);</span><br><span class="line">list.add(<span class="string">"水浒传"</span>);</span><br><span class="line">list.add(<span class="string">"全球通史"</span>);</span><br><span class="line">list.addFirst(<span class="string">"史记"</span>);</span><br><span class="line">list.addLast(<span class="string">"呐喊"</span>);</span><br><span class="line"><span class="comment">// list.addFirst(null);</span></span><br><span class="line"><span class="comment">// list.addLast(null);</span></span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// 获取指定位置处的元素。</span></span><br><span class="line">String str = (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 返回此列表的第一个元素。</span></span><br><span class="line">String str2 = (String) list.getFirst();</span><br><span class="line">System.out.println(str.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置处的元素。</span></span><br><span class="line">String str3 = (String) list.get(list.size() - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回此列表的最后一个元素。</span></span><br><span class="line">String str4 = (String) list.getLast();</span><br><span class="line">System.out.println(str3.equals(str4));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取但不移除此列表的头（第一个元素）。</span></span><br><span class="line">Object element = list.element();</span><br><span class="line">System.out.println(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line">System.out.println(size);</span><br></pre></td></tr></table></figure>

<p>堆栈：先进后出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		<span class="comment">// 压栈，先进后出</span></span><br><span class="line">		list.push(<span class="string">"西游记"</span>);</span><br><span class="line">		list.push(<span class="string">"三国演义"</span>);</span><br><span class="line">		list.push(<span class="string">"石头记"</span>);</span><br><span class="line">		list.push(<span class="string">"水浒传"</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		<span class="comment">// 弹栈</span></span><br><span class="line">		String str1 = (String) list.pop();</span><br><span class="line">		System.out.println(str1);</span><br><span class="line">		String str2 = (String) list.pop();</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		String str3 = (String) list.pop();</span><br><span class="line">		System.out.println(str3);</span><br><span class="line">		String str4 = (String) list.pop();</span><br><span class="line">		System.out.println(str4);</span><br><span class="line">        System.out.println(list.size());<span class="comment">// 0</span></span><br><span class="line">		System.out.println(list); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<p>队列：先进先出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		<span class="comment">// 队列，先进先出</span></span><br><span class="line">		list.offer(<span class="string">"西游记"</span>);</span><br><span class="line">		list.offer(<span class="string">"三国演义"</span>);</span><br><span class="line">		list.offer(<span class="string">"石头记"</span>);</span><br><span class="line">		list.offer(<span class="string">"水浒传"</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		<span class="comment">// 出队列</span></span><br><span class="line">		System.out.println(list.poll());</span><br><span class="line">		System.out.println(list.poll());</span><br><span class="line">		System.out.println(list.poll());</span><br><span class="line">		System.out.println(list.poll());</span><br><span class="line"></span><br><span class="line">		System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">		System.out.println(list.peek()); <span class="comment">// 获取队列的头元素，但是不删除</span></span><br><span class="line">		System.out.println(list.peekFirst()); <span class="comment">// 获取队列的头元素，但是不删除</span></span><br><span class="line">		System.out.println(list.peekLast()); <span class="comment">// 获取队列的最后一个元素，但是不删除</span></span><br></pre></td></tr></table></figure>

<p>ArrayList和 LinkedList的存储查找的优缺点：</p>
<p>1、ArrayList 是采用动态数组来存储元素的，它允许直接用下标号来直接查找对应的元素。但是，但是插入元素要涉及数组元素移动及内存的操作。总结：查找速度快，插入操作慢。</p>
<p>2、LinkedList 是采用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快</p>
<p>问题：有一批数据要存储，要求存储这批数据不能出现重复数据，ArrayList、LinkedList都没法满足需求。解决办法：使用 set集合。</p>
<h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vector: 描述的是一个线程安全的ArrayList。</span><br><span class="line">         </span><br><span class="line">ArrayList： 单线程效率高</span><br><span class="line">Vector   ： 多线程安全的，所以效率低</span><br><span class="line">特有的方法：</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span>  在集合末尾添加元素</span></span><br><span class="line"><span class="function"> E <span class="title">elementAt</span><span class="params">( <span class="keyword">int</span> index)</span> 返回指定角标的元素</span></span><br><span class="line"><span class="function"> Enumeration <span class="title">elements</span><span class="params">()</span>  返回集合中的所有元素，封装到Enumeration对象中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Enumeration 接口：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          测试此枚举是否包含更多的元素。 </span></span><br><span class="line"><span class="function">  E <span class="title">nextElement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">		v.addElement(<span class="string">"aaa"</span>);</span><br><span class="line">		v.addElement(<span class="string">"bbb"</span>);</span><br><span class="line">		v.addElement(<span class="string">"ccc"</span>);</span><br><span class="line">		System.out.println( v );</span><br><span class="line">		System.out.println( v.elementAt(<span class="number">2</span>) );   <span class="comment">// ccc</span></span><br><span class="line">		<span class="comment">// 遍历Vector遍历</span></span><br><span class="line">		Enumeration ens = v.elements();</span><br><span class="line">		<span class="keyword">while</span> ( ens.hasMoreElements() )</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println( ens.nextElement() );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Jdk1<span class="number">.5</span>之后添加的新接口, Collection的父接口. 实现了Iterable的类就是可迭代的.并且支持增强<span class="keyword">for</span>循环。该接口只有一个方法即获取迭代器的方法iterator（）可以获取每个容器自身的迭代器Iterator。（Collection）集合容器都需要获取迭代器（Iterator）于是在<span class="number">5.0</span>后又进行了抽取将获取容器迭代器的iterator（）方法放入到了Iterable接口中。Collection接口进程了Iterable，所以Collection体系都具备获取自身迭代器的方法，只不过每个子类集合都进行了重写（因为数据结构不同）</span><br><span class="line"> Iterator</span><br><span class="line">	<span class="function">Iterator <span class="title">iterator</span><span class="params">()</span> 返回该集合的迭代器对象</span></span><br><span class="line"><span class="function">该类主要用于遍历集合对象，该类描述了遍历集合的常见方法</span></span><br><span class="line"><span class="function">			1：java.lang. Itreable  </span></span><br><span class="line"><span class="function">			 ---| Itreable      接口 实现该接口可以使用增强<span class="keyword">for</span>循环</span></span><br><span class="line"><span class="function">				---| Collection		描述所有集合共性的接口</span></span><br><span class="line"><span class="function">					---| List接口	    可以有重复元素的集合</span></span><br><span class="line"><span class="function">					---| Set接口	    不可以有重复元素的集合</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface Iterable&lt;T&gt;</span></span><br><span class="line"><span class="function">Itreable   该接口仅有一个方法，用于返回集合迭代器对象。</span></span><br><span class="line"><span class="function">	1： Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span>	返回集合的迭代器对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Iterator接口定义的方法</span></span><br><span class="line"><span class="function">Itreator	该接口是集合的迭代器接口类，定义了常见的迭代方法</span></span><br><span class="line"><span class="function">	1：<span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">						判断集合中是否有元素，如果有元素可以迭代，就返回<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function">	2： E <span class="title">next</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">						返回迭代的下一个元素，注意： 如果没有下一个元素时，调用</span></span><br><span class="line"><span class="function">next元素会抛出NoSuchElementException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	3： <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">						从迭代器指向的集合中移除迭代器返回的最后一个元素（可选操作）。</span></span><br><span class="line"><span class="function">思考：为什么next方法的返回类型是Object的呢？ 为了可以接收任意类型的对象,那么返回的时候,不知道是什么类型的就定义为object</span></span><br></pre></td></tr></table></figure>

<p>Collection—迭代的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toArray() </span><br><span class="line">iterator()</span><br></pre></td></tr></table></figure>
<p>迭代器的作用：就是用于抓取集合中的元素。</p>
<p>迭代器的方法：<br>​    hasNext()   问是否有元素可遍历。如果有元素可以遍历，返回true，否则返回false 。</p>
<pre><code>next()    获取元素...
remove()  移除迭代器最后一次返回的元素。</code></pre><p>NoSuchElementException 没有元素的异常。<br>出现的原因： 没有元素可以被迭代了。。。</p>
<p>注意在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，java会抛出异常并发修改异常（ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p>
<p>注意：      ConcurrentModificationException: 当一个集合在循环中即使用引用变量操作集合又使用迭代器操作集合对象， 会抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Stu(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="keyword">this</span>.name+<span class="string">" "</span>+<span class="keyword">this</span>.age+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        Collection&lt;Stu&gt; c = <span class="keyword">new</span> ArrayList&lt;Stu&gt;();</span><br><span class="line">        c.add(<span class="keyword">new</span> Stu(<span class="string">"zhangsan"</span>,<span class="number">22</span>));</span><br><span class="line">        c.add(<span class="keyword">new</span> Stu(<span class="string">"lisi"</span>,<span class="number">21</span>));</span><br><span class="line">        c.add(<span class="keyword">new</span> Stu(<span class="string">"wangwu"</span>,<span class="number">22</span>));</span><br><span class="line">   		Iterator&lt;Stu&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Stu s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            c.add(<span class="keyword">new</span> Student(<span class="string">" "</span>,<span class="number">1</span>));</span><br><span class="line">        	<span class="comment">//  java.util.ConcurrentModificationException</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">"1"</span>);</span><br><span class="line">		list.add(<span class="string">"4"</span>);</span><br><span class="line">		list.add(<span class="string">"2"</span>);</span><br><span class="line">		list.add(<span class="string">"7"</span>);</span><br><span class="line">		System.out.println(list); <span class="comment">//[1,4,2,7]</span></span><br><span class="line">		<span class="comment">// 因为2是最后一个元素了，也就是删除后 没有在调用了迭代器的next方法。</span></span><br><span class="line">		Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			String s = it.next();</span><br><span class="line">			it.remove();</span><br><span class="line"><span class="comment">//			list.add("33");  //java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//			list.remove("1"); //java.util.ConcurrentModificationException</span></span><br><span class="line">			System.out.print(s); <span class="comment">//1427</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();  </span><br><span class="line">		System.out.println(list); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span> <span class="keyword">extends</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="title">listIterator</span>()</span></span><br><span class="line"><span class="class">---| <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">		<span class="title">hasNext</span>()</span></span><br><span class="line"><span class="class">		<span class="title">next</span>()</span></span><br><span class="line"><span class="class">		<span class="title">remove</span>()</span></span><br><span class="line"><span class="class">	   ------| <span class="title">ListIterator</span> <span class="title">Iterator</span>子接口 <span class="title">List</span>专属的迭代器</span></span><br><span class="line"><span class="class">                  <span class="title">add</span>(<span class="title">E</span> <span class="title">e</span>)    将指定的元素插入列表（可选操作）。该元素直接插入到 <span class="title">next</span> 返回的下一个元素的前面（如果有）</span></span><br><span class="line"><span class="class">                  <span class="title">void</span> <span class="title">set</span>(<span class="title">E</span> <span class="title">o</span>)   用指定元素替换 <span class="title">next</span> 或 <span class="title">previous</span> 返回的最后一个元素</span></span><br><span class="line"><span class="class">                  <span class="title">hasPrevious</span>()    逆向遍历列表，列表迭代器有多个元素，则返回 <span class="title">true</span>。</span></span><br><span class="line"><span class="class">                  <span class="title">previous</span>()       返回列表中的前一个元素。</span></span><br><span class="line"><span class="class"><span class="title">Iterator</span>在迭代时，只能对元素进行获取(<span class="title">next</span>())和删除(<span class="title">remove</span>())的操作。</span></span><br><span class="line"><span class="class">对于 <span class="title">Iterator</span> 的子接口<span class="title">ListIterator</span> 在迭代<span class="title">list</span> 集合时，还可以对元素进行添加(<span class="title">add</span>(<span class="title">obj</span>))，修改<span class="title">set</span>(<span class="title">obj</span>)的操作。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 增加：add() 将指定对象存储到容器中</span></span><br><span class="line">list.add(<span class="string">"计算机网络"</span>);</span><br><span class="line">list.add(<span class="string">"现代操作系统"</span>);</span><br><span class="line">list.add(<span class="string">"java编程思想"</span>);</span><br><span class="line">list.add(<span class="string">"java核心技术"</span>);</span><br><span class="line">list.add(<span class="string">"java语言程序设计"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">ListIterator lit = list.listIterator();</span><br><span class="line">lit.next(); <span class="comment">// 计算机网络</span></span><br><span class="line">lit.next(); <span class="comment">// 现代操作系统</span></span><br><span class="line">System.out.println(lit.next()); <span class="comment">// java编程思想</span></span><br><span class="line"><span class="comment">//用指定元素替换 next 或 previous 返回的最后一个元素</span></span><br><span class="line">lit.set(<span class="string">"平凡的世界"</span>);<span class="comment">// 将java编程思想替换为平凡的世界</span></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">System.out.println(lit.next()); <span class="comment">// java编程思想</span></span><br><span class="line"><span class="comment">// 将指定的元素插入列表，该元素直接插入到 next 返回的元素的后</span></span><br><span class="line">lit.add(<span class="string">"平凡的世界"</span>);<span class="comment">// 在java编程思想后添加平凡的世界</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素</span><br><span class="line">用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。</span><br><span class="line">对象的相等性</span><br><span class="line">引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。</span><br><span class="line">	如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object  hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回<span class="keyword">true</span></span><br><span class="line">该集合中没有特有的方法，直接继承自Collection。</span><br><span class="line">---| Itreable      接口 实现该接口可以使用增强<span class="keyword">for</span>循环</span><br><span class="line">				---| Collection		描述所有集合共性的接口</span><br><span class="line">					---| List接口	    可以有重复元素的集合</span><br><span class="line">                            ---| ArrayList   </span><br><span class="line">                            ---|  LinkedList</span><br><span class="line">					---| Set接口	    不可以有重复元素的集合</span><br><span class="line">案例：set集合添加元素并使用迭代器迭代元素。</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Set 集合存和取的顺序不一致。</span></span><br><span class="line">		Set hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">		hs.add(<span class="string">"世界军事"</span>);</span><br><span class="line">		hs.add(<span class="string">"兵器知识"</span>);</span><br><span class="line">		hs.add(<span class="string">"舰船知识"</span>);</span><br><span class="line">		hs.add(<span class="string">"汉和防务"</span>);</span><br><span class="line">		System.out.println(hs);</span><br><span class="line">		<span class="comment">// [舰船知识, 世界军事, 兵器知识, 汉和防务]</span></span><br><span class="line">		Iterator it = hs.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h2><p>​                —|Set接口     不可以有重复元素的集合</p>
<p>​                            —| HashSet  </p>
<p>线程不安全，存取速度快。底层是以哈希表实现的。</p>
<p>hashSet的实现原理：</p>
<pre><code>往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。

情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。

情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&#123; 编号:"</span>+ <span class="keyword">this</span>.id+<span class="string">" 姓名："</span>+ <span class="keyword">this</span>.name+<span class="string">"&#125;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=======hashCode====="</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"======equals======"</span>);</span><br><span class="line">		Person p = (Person)obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id==p.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="number">110</span>,<span class="string">"狗娃"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="number">220</span>,<span class="string">"狗剩"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="number">330</span>,<span class="string">"铁蛋"</span>));</span><br><span class="line">		<span class="comment">//在现实生活中只要编号一致就为同一个人.</span></span><br><span class="line">		System.out.println(<span class="string">"添加成功吗？"</span>+set.add(<span class="keyword">new</span> Person(<span class="number">110</span>,<span class="string">"狗娃"</span>)));</span><br><span class="line">		System.out.println(<span class="string">"集合的元素："</span>+set);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">=======hashCode=====</span><br><span class="line">=======hashCode=====</span><br><span class="line">=======hashCode=====</span><br><span class="line">=======hashCode=====</span><br><span class="line">======equals======</span><br><span class="line">添加成功吗？<span class="keyword">false</span></span><br><span class="line">集合的元素：[&#123; 编号:<span class="number">330</span> 姓名：铁蛋&#125;, &#123; 编号:<span class="number">220</span> 姓名：狗剩&#125;, &#123; 编号:<span class="number">110</span> 姓名：狗娃&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h2><p>treeSet要注意的事项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。</span><br><span class="line"> 	<span class="number">2</span>. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素</span><br><span class="line">   的比较规则定义在compareTo(T o)方法上。 </span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. 如果比较元素的时候，compareTo方法返回 的是<span class="number">0</span>，那么该元素就被视为重复元素，不允许添加.(注意：TreeSet与HashCode、equals方法是没有任何关系。)</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span>. 往TreeSet添加元素的时候, 如果元素本身没有具备自然顺序 的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个</span><br><span class="line">     比较器。</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span>. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口， 在创建TreeSet对象的时候也传入了比较器</span><br><span class="line">     那么是以比较器的比较规则优先使用。</span><br><span class="line">   如何自定义定义比较器： 自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法内即可。</span><br><span class="line">   	自定义比较器的格式 ：</span><br><span class="line"></span><br><span class="line">   		<span class="class"><span class="keyword">class</span>  类名  <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   		&#125;</span><br><span class="line"></span><br><span class="line">   推荐使用：使用比较器(Comparator)。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Emp</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> salary;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&#123; 编号："</span>+  <span class="keyword">this</span>.id+<span class="string">" 姓名："</span>+ <span class="keyword">this</span>.name+<span class="string">" 薪水："</span>+ <span class="keyword">this</span>.salary+<span class="string">"&#125;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//@Override //元素与元素之间的比较规则。</span></span><br><span class="line">	<span class="comment">// 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Emp o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		System.out.println(this.name+"compare"+ e.name);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.salary- o.salary;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Emp</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Emp o1, Emp o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.id-o2.id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 </span></span><br><span class="line">	<span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">	public int compare(Object o1, Object o2) &#123;</span></span><br><span class="line"><span class="comment">		Emp e1 = (Emp) o1;</span></span><br><span class="line"><span class="comment">		Emp e2 = (Emp) o2;</span></span><br><span class="line"><span class="comment">		return e1.id - e2.id;</span></span><br><span class="line"><span class="comment">	&#125;*/</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个比较器对象</span></span><br><span class="line">		MyComparator comparator = <span class="keyword">new</span> MyComparator();</span><br><span class="line">		<span class="comment">//创建TreeSet的时候传入比较器</span></span><br><span class="line">		TreeSet tree = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">		</span><br><span class="line">		tree.add(<span class="keyword">new</span> Emp(<span class="number">110</span>, <span class="string">"老陆"</span>, <span class="number">100</span>));</span><br><span class="line">		tree.add(<span class="keyword">new</span> Emp(<span class="number">113</span>, <span class="string">"老钟"</span>, <span class="number">200</span>));</span><br><span class="line">		tree.add(<span class="keyword">new</span> Emp(<span class="number">220</span>, <span class="string">"老汤"</span>, <span class="number">300</span>));</span><br><span class="line">		tree.add(<span class="keyword">new</span> Emp(<span class="number">120</span>, <span class="string">"老蔡"</span>, <span class="number">500</span>));</span><br><span class="line">		System.out.println(<span class="string">"集合的元素："</span>+tree);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串比较规则"><a href="#字符串比较规则" class="headerlink" title="字符串比较规则"></a>字符串比较规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TreeSet是可以对字符串进行排序的，因为字符串已经实现了Comparable接口。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串的比较规则：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	情况一： 对应位置有不同的字符出现，就比较的就是对应位置不同的字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	情况 二：对应位置上的字符都一样，比较的就是字符串的长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		TreeSet tree = <span class="keyword">new</span> TreeSet();</span><br><span class="line">		tree.add(<span class="string">"abcccccccccccccccccc"</span>);</span><br><span class="line">		tree.add(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(tree); <span class="comment">// [abc, abcccccccccccccccccc]</span></span><br><span class="line">		System.out.println(<span class="string">"abw"</span>.compareTo(<span class="string">"abcccccccccccc"</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkHashList集合"><a href="#LinkHashList集合" class="headerlink" title="LinkHashList集合"></a>LinkHashList集合</h2><p>会保存插入的顺序。</p>
<p>看到array，就要想到角标。</p>
<p>看到link，就要想到first，last。</p>
<p>看到hash，就要想到hashCode,equals.</p>
<p>看到tree，就要想到两个接口。Comparable，Comparator。</p>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p>双列集合</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map学习体系：</span><br><span class="line"> ---| Map  接口    将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</span><br><span class="line">			---| HashMap  采用哈希表实现，所以无序</span><br><span class="line">            ---| TreeMap   可以对健进行排序</span><br><span class="line"></span><br><span class="line">---|Hashtable:</span><br><span class="line">底层是哈希表数据结构，线程是同步的，不可以存入<span class="keyword">null</span>键，<span class="keyword">null</span>值。</span><br><span class="line">效率较低，被HashMap 替代。</span><br><span class="line">---|HashMap:</span><br><span class="line">底层是哈希表数据结构，线程是不同步的，可以存入<span class="keyword">null</span>键，<span class="keyword">null</span>值。</span><br><span class="line">要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</span><br><span class="line">---| LinkedHashMap：</span><br><span class="line">该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</span><br><span class="line">---|TreeMap:</span><br><span class="line">底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。<span class="keyword">return</span> <span class="number">0</span>，来判断键的唯一性。</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、添加：</span><br><span class="line">	<span class="number">1</span>、<span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span>    （可以相同的key值，但是添加的value值会覆</span></span><br><span class="line"><span class="function">盖前面的，返回值是前一个，如果没有就返回<span class="keyword">null</span>）                                          </span></span><br><span class="line"><span class="function">	2、<span class="title">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span>  从指定映射中将所有映射关</span></span><br><span class="line"><span class="function">系复制到此映射中（可选操作）。</span></span><br><span class="line"><span class="function">2、删除</span></span><br><span class="line"><span class="function">	1、<span class="title">remove</span><span class="params">()</span>    删除关联对象，指定key对象</span></span><br><span class="line"><span class="function">	2、<span class="title">clear</span><span class="params">()</span>     清空集合对象</span></span><br><span class="line"><span class="function">3、获取</span></span><br><span class="line"><span class="function">     1：value <span class="title">get</span><span class="params">(key)</span></span>; 可以用于判断键是否存在的情况。当指定的键不存在的时候，返</span><br><span class="line">回的是<span class="keyword">null</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、判断：</span><br><span class="line">	<span class="number">1</span>、<span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>   长度为0返回<span class="keyword">true</span>否则<span class="keyword">false</span></span></span><br><span class="line"><span class="function">    2、<span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>  判断集合中是否包含指定的key</span></span><br><span class="line"><span class="function">	3、<span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>  判断集合中是否包含指定的value</span></span><br><span class="line"><span class="function">	4、长度：</span></span><br><span class="line"><span class="function">Int size（）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line">		<span class="comment">// 定义一个Map的容器对象</span></span><br><span class="line">		Map&lt;String, Integer &gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Integer &gt;();</span><br><span class="line">		map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">		map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">		map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">		map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">		System.out.println(map1);  <span class="comment">//&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line">		<span class="comment">// 添加重复的键值（值不同）,会返回集合中原有（重复键）的值System.out.println(map1.put("jack", 30)); //20</span></span><br><span class="line">		       </span><br><span class="line">		Map&lt;String, Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		map2.put(<span class="string">"张三丰"</span>, <span class="number">100</span>);</span><br><span class="line">		map2.put(<span class="string">"虚竹"</span>, <span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">"map2:"</span> + map2);</span><br><span class="line">		<span class="comment">// 从指定映射中将所有映射关系复制到此映射中。</span></span><br><span class="line">		map1.putAll(map2);</span><br><span class="line">		System.out.println(<span class="string">"map1:"</span> + map1);</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">		<span class="comment">// 指定key，返回删除的键值对映射的值。</span></span><br><span class="line">		System.out.println(<span class="string">"value:"</span> + map1.remove(<span class="string">"java"</span>));</span><br><span class="line">		map1.clear();</span><br><span class="line">		System.out.println(<span class="string">"map1:"</span> + map1);</span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">		<span class="comment">// V get(Object key) 通过指定的key对象获取value对象</span></span><br><span class="line">		<span class="comment">// int size() 获取容器的大小</span></span><br><span class="line">		System.out.println(<span class="string">"value:"</span> + map1.get(<span class="string">"jack"</span>));</span><br><span class="line">		System.out.println(<span class="string">"map.size:"</span> + map1.size());</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line">		Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">		map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">		map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">		map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">		System.out.println(map1);</span><br><span class="line">		System.out.println(<span class="string">"isEmpty:"</span> + map1.isEmpty());</span><br><span class="line">		System.out.println(<span class="string">"containskey:"</span> + map1.containsKey(<span class="string">"jack"</span>));</span><br><span class="line">		System.out.println(<span class="string">"containsvalues:"</span> + map1.containsValue(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><p>方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、将map 集合中所有的键取出存入set集合。</span><br><span class="line">		<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span>   返回所有的key对象的Set集合</span></span><br><span class="line"><span class="function">                             再通过get方法获取键对应的值。</span></span><br><span class="line"><span class="function">2、 <span class="title">values</span><span class="params">()</span> ，获取所有的值.</span></span><br><span class="line"><span class="function">		Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span>不能获取到key对象</span></span><br><span class="line"><span class="function">3、 Map.Entry对象  推荐使用   重点</span></span><br><span class="line"><span class="function">		Set&lt;Map.Entry&lt;k,v&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">将map 集合中的键值映射关系打包成一个对象Map.Entry对象通过Map.Entry 对象的getKey，getValue获取其键和值。</span></span><br></pre></td></tr></table></figure>

<p>第一种方式:使用keySet</p>
<p>将Map转成Set集合（keySet()），通过Set的迭代器取出Set集合中的每一个元素（Iterator）就是Map集合中的所有的键，再通过get方法获取键对应的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"bbbb"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; ks = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = ks.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	Integer key = it.next();</span><br><span class="line">	String value = map.get(key);</span><br><span class="line">	System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式: 通过values 获取所有值,不能获取到key对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"bbbb"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">Collection&lt;String&gt; vs = map.values();</span><br><span class="line">Iterator&lt;String&gt; it = vs.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	String value = it.next();</span><br><span class="line">	System.out.println(<span class="string">" value="</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式: Map.Entry</p>
<p>publicstatic interface Map.Entry&lt;K,V&gt;</p>
<p>通过Map中的entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的Set集合。</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</p>
<p>面向对象的思想将map集合中的键和值映射关系打包为一个对象，就是Map.Entry，将该对象存入Set集合，Map.Entry是一个对象，那么该对象具备的getKey，getValue获得键和值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"bbbb"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的Map.Entry对象的Set集合 Map.Entry包含了key和value对象</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; es = map.entrySet();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = es.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回的是封装了key和value对象的Map.Entry对象</span></span><br><span class="line">	Map.Entry&lt;Integer, String&gt; en = it.next();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Map.Entry对象中封装的key和value对象</span></span><br><span class="line">	Integer key = en.getKey();</span><br><span class="line">	String value = en.getValue();</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h2><p>HashMap的存储原理：</p>
<pre><code>往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该
元素在哈希表中的存储位置。 
情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。

情况2：如果算出 的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较
，如果equals方法返回 的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为
重复元素，不允存储</code></pre><p>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode() + age * <span class="number">37</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">			Person p = (Person) obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person@name:"</span> + <span class="keyword">this</span>.name + <span class="string">" age:"</span> + <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap&lt;Person, String&gt; hm = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">		hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="string">"1001"</span>);</span><br><span class="line">		hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">		hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">		hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">		hm.put(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">25</span>), <span class="string">"1005"</span>);</span><br><span class="line">		System.out.println(hm);</span><br><span class="line">		System.out.println(hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1006"</span>));</span><br><span class="line"></span><br><span class="line">		Set&lt;Entry&lt;Person, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">		Iterator&lt;Entry&lt;Person, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry&lt;Person, String&gt; next = it.next();</span><br><span class="line">			Person key = next.getKey();</span><br><span class="line">			String value = next.getValue();</span><br><span class="line">			System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h2><p>TreeMap的排序，TreeMap可以对集合中的键进行排序。如何实现键的排序？</p>
<p>方式一：元素自身具备比较性</p>
<p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。</p>
<p>方式二：容器具备比较性</p>
<p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</p>
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；</p>
<p>注意：在重写compareTo或者compare方法时，必须要明确比较的主要条件相等时要比较次要条件。（假设姓名和年龄一直的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接return 0，以为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回0.）</p>
<p>通过return 0来判断唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;<span class="comment">//implements Comparable&lt;Emp&gt;&#123;</span></span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> salary;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[姓名："</span>+<span class="keyword">this</span>.name+<span class="string">" 薪水："</span>+ <span class="keyword">this</span>.salary+<span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@Override</span></span><br><span class="line"><span class="comment">	public int compareTo(Emp o) &#123;</span></span><br><span class="line"><span class="comment">		return this.salary - o.salary;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Emp</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Emp o1, Emp o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.salary - o2.salary;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*	TreeMap&lt;Character, Integer&gt; tree = new TreeMap&lt;Character, Integer&gt;();</span></span><br><span class="line"><span class="comment">		tree.put('c',10);</span></span><br><span class="line"><span class="comment">		tree.put('b',2);</span></span><br><span class="line"><span class="comment">		tree.put('a',5);</span></span><br><span class="line"><span class="comment">		tree.put('h',12);</span></span><br><span class="line"><span class="comment">		System.out.println(tree);*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个自定义比较器</span></span><br><span class="line">		MyComparator comparator = <span class="keyword">new</span> MyComparator();</span><br><span class="line">		</span><br><span class="line">		TreeMap&lt;Emp, String&gt; tree = <span class="keyword">new</span> TreeMap&lt;Emp, String&gt;(comparator);</span><br><span class="line">		tree.put(<span class="keyword">new</span> Emp(<span class="string">"冰冰"</span>, <span class="number">2000</span>),<span class="string">"001"</span>);</span><br><span class="line">		tree.put(<span class="keyword">new</span> Emp(<span class="string">"家宝"</span>, <span class="number">1000</span>),<span class="string">"002"</span>);</span><br><span class="line">		tree.put(<span class="keyword">new</span> Emp(<span class="string">"习总"</span>, <span class="number">3000</span>),<span class="string">"003"</span>);</span><br><span class="line">		tree.put(<span class="keyword">new</span> Emp(<span class="string">"克强"</span>, <span class="number">5000</span>),<span class="string">"005"</span>);</span><br><span class="line">		</span><br><span class="line">		tree.put(<span class="keyword">new</span> Emp(<span class="string">"财厚"</span>, <span class="number">5000</span>),<span class="string">"008"</span>);</span><br><span class="line">		System.out.println(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Collections与Arrays"><a href="#Collections与Arrays" class="headerlink" title="Collections与Arrays"></a>Collections与Arrays</h1><p>集合框架中的工具类：特点：该工具类中的方法都是静态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Collections：常见方法：</span><br><span class="line"><span class="number">1</span>，对list进行二分查找：</span><br><span class="line">    前提该集合一定要有序。</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(list,key)</span></span>;</span><br><span class="line">    <span class="comment">//必须根据元素自然顺序对列表进行升级排序</span></span><br><span class="line">    <span class="comment">//要求list 集合中的元素都是Comparable 的子类。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(list,key,Comparator)</span></span>;</span><br><span class="line"><span class="number">2</span>，对list集合进行排序。</span><br><span class="line">    sort(list); </span><br><span class="line">    <span class="comment">//对list进行排序,其实使用的事list容器中的对象的compareTo方法</span></span><br><span class="line">    sort(list,comaprator);</span><br><span class="line">	<span class="comment">//按照指定比较器进行排序</span></span><br><span class="line"><span class="number">3</span>，对集合取最大值或者最小值。</span><br><span class="line">	max(Collection)</span><br><span class="line">	max(Collection,comparator)</span><br><span class="line">	min(Collection)</span><br><span class="line">	min(Collection,comparator)</span><br><span class="line"><span class="number">4</span>，对list集合进行反转。</span><br><span class="line">	reverse(list);</span><br><span class="line"><span class="number">5</span>，对比较方式进行强行逆转。</span><br><span class="line">	<span class="function">Comparator <span class="title">reverseOrder</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Comparator <span class="title">reverseOrder</span><span class="params">(Comparator)</span></span>;</span><br><span class="line"><span class="number">6</span>，对list集合中的元素进行位置的置换。</span><br><span class="line">	swap(list,x,y);</span><br><span class="line"><span class="number">7</span>，对list集合进行元素的替换。如果被替换的元素不存在，那么原集合不变。</span><br><span class="line">	replaceAll(list,old,<span class="keyword">new</span>);</span><br><span class="line"><span class="number">8</span>，可以将不同步的集合变成同步的集合。</span><br><span class="line">    <span class="function">Set <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br><span class="line"><span class="function">    Map <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span></span><br><span class="line"><span class="function">    List <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function">9. 如果想要将集合变数组：</span></span><br><span class="line"><span class="function">	可以使用Collection 中的toArray 方法。注意：是Collection不是Collections工具类</span></span><br><span class="line"><span class="function">传入指定的类型数组即可，该数组的长度最好为集合的size。</span></span><br></pre></td></tr></table></figure>

<p>Arrays:用于对数组操作的工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>， 二分查找,数组需要有序</span><br><span class="line">    binarySearch(<span class="keyword">int</span>[])</span><br><span class="line">    binarySearch(<span class="keyword">double</span>[])</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>，数组排序</span><br><span class="line">    sort(<span class="keyword">int</span>[])</span><br><span class="line">    sort(<span class="keyword">char</span>[])……</span><br><span class="line"><span class="number">2</span>，	将数组变成字符串。</span><br><span class="line"> toString(<span class="keyword">int</span>[])</span><br><span class="line"><span class="number">3</span>，	复制数组。</span><br><span class="line"> copyOf();</span><br><span class="line"><span class="number">4</span>，	复制部分数组。</span><br><span class="line">	copyOfRange():</span><br><span class="line"><span class="number">5</span>，	比较两个数组是否相同。</span><br><span class="line">	equals(<span class="keyword">int</span>[],<span class="keyword">int</span>[]);</span><br><span class="line"><span class="number">6</span>，	将数组变成集合。</span><br><span class="line">	<span class="function">List <span class="title">asList</span><span class="params">(T[])</span></span>;</span><br><span class="line">这样可以通过集合的操作来操作数组中元素，</span><br><span class="line">但是不可以使用增删方法，add，remove。因为数组长度是固定的，会出现</span><br><span class="line">UnsupportOperationExcetion。</span><br><span class="line">可以使用的方法：contains，indexOf。。。</span><br><span class="line">如果数组中存入的基本数据类型，那么asList会将数组实体作为集合中的元素。</span><br><span class="line">如果数组中的存入的引用数据类型，那么asList会将数组中的元素作为集合中</span><br><span class="line">的元素。</span><br></pre></td></tr></table></figure>

<h1 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型(Generic)"></a>泛型(Generic)</h1><p>泛型编译时期有效，避免了类型强制转换的问题。</p>
<p>格式  通过&lt;&gt; 来指定容器中元素的类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">细节一</span><br><span class="line">声明好泛型类型之后,集合中只能存放特定类型元素</span><br><span class="line"></span><br><span class="line">细节二:</span><br><span class="line">泛型类型必须是引用类型(基本数据类型不行)</span><br><span class="line"></span><br><span class="line">细节三: 使用泛型后取出元素不需要类型转换.</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">当函数中使用了一个不明确的数据类型，那么在函数上就可以进行泛型的定义。</span><br><span class="line">		  <span class="keyword">public</span> &lt;泛型的声明&gt; 返回值类型  函数名( 泛型 变量名  )&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">new</span> Demo6().getData(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">细节：</span><br><span class="line">使用泛型方法前需要进行泛型声明，使用一对尖括号 &lt;泛型&gt;，声明的位置在<span class="keyword">static</span>后返回值类型前。</span><br><span class="line">当一个类中有多个函数声明了泛型，那么该泛型的声明可以声明在类上。</span><br></pre></td></tr></table></figure>

<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">定义格式：</span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;类型&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用泛型类，创建对象的时候需要指定具体的类型</span></span><br><span class="line">		<span class="keyword">new</span> Demo&lt;Integer&gt;().getData(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反序任意类型数组</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">				T temp = arr[start];</span><br><span class="line">				arr[start] = arr[end];</span><br><span class="line">				arr[end] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>泛型类细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建对象的时候要指定泛型的具体类型</span><br><span class="line"><span class="number">2</span>、创建对象时可以不指定泛型的具体类型(和创建集合对象一样)。默认是Object，例如我们使用集合存储元素的时候没有使用泛型就是那么参数的类型就是Object</span><br><span class="line"><span class="number">3</span>、类上面声明的泛型只能应用于非静态成员函数，如果静态函数需要使用泛型，那么需要在函数上独立声明。</span><br><span class="line"><span class="number">4</span>、如果建立对象后指定了泛型的具体类型，那么该对象操作方法时，这些方法只能操作一种数据类型。</span><br><span class="line"><span class="number">5</span>、所以既可以在类上的泛型声明，也可以在同时在该类的方法中声明泛型。</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyInter&lt;String&gt; my = <span class="keyword">new</span> MyInter&lt;String&gt;();</span><br><span class="line">		my.print(<span class="string">"泛型"</span>);</span><br><span class="line"></span><br><span class="line">		MyInter2 my2 = <span class="keyword">new</span> MyInter2();</span><br><span class="line">		my.print(<span class="string">"只能传字符串"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现不知为何类型时可以这样定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"myprint:"</span> + t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用接口时明确具体类型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInter2</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"myprint:"</span> + t);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通配符：？</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">可以对类型进行限定范围。</span><br><span class="line">？extends E: 接收E类型或者E的子类型。</span><br><span class="line">? <span class="keyword">super</span> E: 接收E类型或者E的父类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">限定通配符的上边界：</span><br><span class="line">extends </span><br><span class="line">接收Number 类型或者Number的子类型</span><br><span class="line">正确：Vector&lt;? extends Number&gt; x = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">错误：Vector&lt;? extends Number&gt; x = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">限定通配符的下边界</span><br><span class="line"><span class="keyword">super</span></span><br><span class="line">接收Integer 或者Integer的父类型</span><br><span class="line">正确：Vector&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> Vector&lt;Number&gt;();</span><br><span class="line">错误：Vector&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> Vector&lt;Byte&gt;();</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>JDK5中的泛型允许程序员在编写集合代码时，就限制集合的处理类型，从而把原来程序运行时可能发生问题，转变为编译时的问题，以此提高程序的可读性和稳定</p>
<p>注意：泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，生成的class文件中将不再带有泛形信息，以此使程序运行效率不受到影响，这个过程称之为“擦除”。</p>
<p>泛型的基本术语，以ArrayList<E>为例：&lt;&gt;念着typeof</p>
<p>ArrayList<E>中的E称为类型参数变量</p>
<p>ArrayList<Integer>中的Integer称为实际类型参数</p>
<p>整个称为ArrayList<E>泛型类型</p>
<p>整个ArrayList<Integer>称为参数化的类型ParameterizedType</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>zxucooly
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zxucooly.github.io/2017/12/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E9%9B%86%E5%90%88_%E6%B3%9B%E5%9E%8B/" title="java基础知识-集合">https://zxucooly.github.io/2017/12/02/Java基础知识/5-Java基础知识_集合_泛型/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"><i class="fa fa-tag"></i> java基础知识</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/12/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3-Java%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1api/" rel="prev" title="java基础知识-常用API">
      <i class="fa fa-chevron-left"></i> java基础知识-常用API
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/12/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6-Java_%E6%96%87%E4%BB%B6_%E6%B5%81%E5%AF%B9%E8%B1%A1/" rel="next" title="java基础知识-文件">
      java基础知识-文件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">1.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是集合？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是集合？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合和数组的区别？"><span class="nav-number">1.2.</span> <span class="nav-text">集合和数组的区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合框架"><span class="nav-number">2.</span> <span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合类（Collection）"><span class="nav-number">3.</span> <span class="nav-text">集合类（Collection）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection的共性方法"><span class="nav-number">3.1.</span> <span class="nav-text">Collection的共性方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List集合"><span class="nav-number">4.</span> <span class="nav-text">List集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List集合特有的方法"><span class="nav-number">4.1.</span> <span class="nav-text">List集合特有的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList集合"><span class="nav-number">4.2.</span> <span class="nav-text">ArrayList集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkList集合"><span class="nav-number">4.3.</span> <span class="nav-text">LinkList集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector集合"><span class="nav-number">4.4.</span> <span class="nav-text">Vector集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">4.5.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ListIterator"><span class="nav-number">4.5.1.</span> <span class="nav-text">ListIterator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set集合"><span class="nav-number">5.</span> <span class="nav-text">Set集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet集合"><span class="nav-number">5.1.</span> <span class="nav-text">HashSet集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeSet集合"><span class="nav-number">5.2.</span> <span class="nav-text">TreeSet集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串比较规则"><span class="nav-number">5.3.</span> <span class="nav-text">字符串比较规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkHashList集合"><span class="nav-number">5.4.</span> <span class="nav-text">LinkHashList集合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map集合"><span class="nav-number">6.</span> <span class="nav-text">Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法"><span class="nav-number">6.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历Map"><span class="nav-number">6.2.</span> <span class="nav-text">遍历Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap集合"><span class="nav-number">6.3.</span> <span class="nav-text">HashMap集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap集合"><span class="nav-number">6.4.</span> <span class="nav-text">TreeMap集合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collections与Arrays"><span class="nav-number">7.</span> <span class="nav-text">Collections与Arrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型-Generic"><span class="nav-number">8.</span> <span class="nav-text">泛型(Generic)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型方法"><span class="nav-number">8.1.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型类"><span class="nav-number">8.2.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型接口"><span class="nav-number">8.3.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型通配符"><span class="nav-number">8.4.</span> <span class="nav-text">泛型通配符</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zxucooly"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">zxucooly</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnp4dWNvb2x5QGdtYWlsLmNvbQ==" title="E-Mail → mailto:zxucooly@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zxu's blog</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
